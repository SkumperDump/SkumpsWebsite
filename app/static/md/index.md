# Hello,

First off, my name is Scotty! For bureaucratic reasons, I use my full legal name on paper. However, I figure you should know what my friends call me! 

Anyways, who am I? Well, I started out as a chemist that used to want to be an aerospace engineer. I also had a long childhood fixation with architecture. 

Recently, I have accepted the fact that I like to keep things broad. I have found that the broader my knowledge, the more options I have when solving a given problem.

Don't get me wrong, problem-solving is and should be challenging. One can quickly make it harder on themselves in ways that are easily counteracted and just as easy to fall for.

Historically, my approach to solving something hard is by taking multiple passes at the topic to gain insight with each strafe. I find this narrows down the scope of my misunderstanding to the point where the whole subject jumps out at me at once. This requires switching sub-topics constantly and grabbing on to whatever straws grip best.

It can be incredibly hard to pivot to another topic if you have lost track of the steps you took to get to where you are. This requires time spent re-familiarizing oneself with the past, and there is no guarantee you will not continue down the wrong path again once you resume.

I find that an easy solution to these intertwined problem-solving hindrances is to be committed to using unit tests. Therefore, given I feel that this will be a **HUGE** part of my work for you: developing the code you need in a way that is well-documented, efficient, and secure. I will take my time here to explain the benefits of unit testing.

I find unit testing eventually becomes a mindset, and I think it is the one thing a developer can do to make everyone, including themselves, happy! 

A good unit test turns a section of code into something much more defined to a programmer. It elaborates to a developer what a section of code has been exposed to, and it validates some simple truths that help to ensure the overall system is running as planned. 

You can even turn broken code, that is, code that predictably returns false when asked if it can perform a specific task, into a way of developing a system without having access to all of its components. When this method is combined with proper exception handling, I find that programming is much more predictable and programs are easier to pick apart during their eon-esque lifespan.

Without any testing, coding is a messy and mad dash toward an ever-shifting target. But, when good testing is used, as code is being developed, each addition to a code base is intentional and vetted.

Your tests may also be a reference for other programmers and will hopefully express the inner workings of your program. 

In a worst-case scenario, this helps keep track of what you have already tried for a given section of code. Thus, it is easier to narrow down the exact situations that are causing run-time issues. I find this to be immensely helpful, as no matter what project I am working on, I am keeping track of my code as I write it, and then can hop back into what I was doing, with a degree of certainty that it works, by studying my unit tests.

Unit tests can lead you astray if they are not designed well. An easy way to design a good unit test is to keep it as simple as possible. I find it is much more insightful to write many small tests rather than a few large ones.
