# To whom it may concern,

First off, my name is Scotty! For bureaucratic reasons, I use my legal name. However, I figure you should know what my friends call me! 

Anyways, who am I? Well, I started out as a chemist that used to want to be an aerospace engineer. I also had a long childhood fixation with architecture. Eventually, I learned that I like to keep things broad, and that the broader my knowledge, the more options I have when it comes to solving a given problem.

Don't get me wrong, problem solving is, and should be, challenging. Its even more difficult if you don't know when to shift gears and focus on something else, and thats if you havn't lost track of where you even are. I find that an easy solution to both of these issues is to be committed to using unit tests. Therefore, given that I feel this will be a HUGE part of my working for you: developing any code you need in a way that is well documented, efficient, and secure. I will take my time here to explain the benefits of unit testing.

I find unit testing eventually becomes a mindset, and I think it is the one thing a developer can do to make everyone, including themselves, happy! 

A good unit test turns a section of code into something much more defined to a programmer. A unit test elaborates to a developer what a section of code has been exposed to. It validates some simple truths that I feel are important to insuring that a system is running as planned. You can even turn broken code, that is, code that predictably returns false when asked if it can perform a given task, into a way of developing a system without having access to all of its components. When combined with proper exception handling, I find that programming is more predictable and easier to pick apart when something has gone wrong. Without any testing, coding is a messy and mad dash to the finish. When good testing is used, as code is being developed, in the form of unit tests, each addition to a code base is intentional. 

Good tests allow you to understand the limits of your code imediately just by running it.You can turn your code into a limited set of inputs and outputs that return true or false, which helps to ensure you have intentionally pondered the scenarios that your sections of code will be exposed to. Not only have you personally testing the code that you have written, given that you have tested individual sub-components, the minute workings of your design are captured. Worst case scenario, you can keep track of what you have already tried for a given section of code. This helps to narrow down the exact situations that are causing run time issues. I find this to be immensely helpful, as no matter what project I am working on, I can keep track of my code as I write it, and then hop back into what I was doing, with a degree of certainty that it works, by studying my unit tests.

This is also a great mindset as it brings some of the benefits of modern languages without the modern overhead. You become part of the compiler and your code, even if it is without the oversight of say... a type checker, is still vetted for incompatibilities. As it is designed. 

I find that almost every program used to aid a programmer is almost just a form of unit tests. As afterall, progammers really are just glorified unit testers.
